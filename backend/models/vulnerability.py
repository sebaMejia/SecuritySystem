from datetime import datetime
from sqlalchemy import Column, Integer, String, DateTime, Text, Float, ForeignKey, Boolean
from sqlalchemy.orm import relationship
from backend.models.security_event import db
import uuid

class Vulnerability(db.Model):
    __tablename__ = 'vulnerabilities'

    id = Column(Integer, primary_key=True)
    vuln_id = Column(String(36), unique=True, nullable=False, default=lambda: str(uuid.uuid4()))
    
    # Vulnerability identification
    cve_id = Column(String(20))  # CVE-2023-12345
    title = Column(String(255), nullable=False)
    description = Column(Text)
    
    # Severity and scoring
    cvss_score = Column(Float)  # 0.0 to 10.0
    cvss_vector = Column(String(100))
    severity = Column(String(20))  # LOW, MEDIUM, HIGH, CRITICAL
    
    # Affected systems
    affected_device_id = Column(Integer, ForeignKey('network_devices.id'))
    affected_device = relationship("NetworkDevice", backref="vulnerabilities")
    
    # Vulnerability details
    affected_software = Column(String(255))
    affected_version = Column(String(100))
    patch_available = Column(Boolean, default=False)
    patch_version = Column(String(100))
    
    # Risk assessment
    exploitability = Column(String(20))  # LOW, MEDIUM, HIGH
    impact = Column(String(20))  # LOW, MEDIUM, HIGH
    attack_vector = Column(String(50))  # NETWORK, ADJACENT, LOCAL, PHYSICAL
    attack_complexity = Column(String(20))  # LOW, HIGH
    
    # Status tracking
    status = Column(String(20), default='OPEN')  # OPEN, PATCHED, MITIGATED, ACCEPTED, FALSE_POSITIVE
    assigned_to = Column(String(100))
    remediation_notes = Column(Text)
    remediation_date = Column(DateTime)
    
    # Discovery information
    discovered_by = Column(String(100))  # scanner name or manual
    discovery_method = Column(String(100))
    first_seen = Column(DateTime, default=datetime.utcnow)
    last_seen = Column(DateTime, default=datetime.utcnow)
    
    # References and links
    references = Column(Text)  # JSON array of reference URLs
    vendor_advisory = Column(String(255))
    proof_of_concept = Column(Text)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    def to_dict(self):
        return {
            'id': self.id,
            'vuln_id': self.vuln_id,
            'cve_id': self.cve_id,
            'title': self.title,
            'description': self.description,
            'cvss_score': self.cvss_score,
            'cvss_vector': self.cvss_vector,
            'severity': self.severity,
            'affected_device_id': self.affected_device_id,
            'affected_software': self.affected_software,
            'affected_version': self.affected_version,
            'patch_available': self.patch_available,
            'patch_version': self.patch_version,
            'exploitability': self.exploitability,
            'impact': self.impact,
            'attack_vector': self.attack_vector,
            'attack_complexity': self.attack_complexity,
            'status': self.status,
            'assigned_to': self.assigned_to,
            'remediation_notes': self.remediation_notes,
            'remediation_date': self.remediation_date.isoformat() if self.remediation_date else None,
            'discovered_by': self.discovered_by,
            'discovery_method': self.discovery_method,
            'first_seen': self.first_seen.isoformat() if self.first_seen else None,
            'last_seen': self.last_seen.isoformat() if self.last_seen else None,
            'references': self.references,
            'vendor_advisory': self.vendor_advisory,
            'proof_of_concept': self.proof_of_concept,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None
        }

    @classmethod
    def get_critical_vulns(cls):
        return cls.query.filter_by(severity='CRITICAL').all()
    
    @classmethod
    def get_open_vulns(cls):
        return cls.query.filter_by(status='OPEN').all()
    
    @classmethod
    def get_vulns_by_device(cls, device_id):
        return cls.query.filter_by(affected_device_id=device_id).all()
    
    @classmethod
    def get_high_cvss_vulns(cls, threshold=7.0):
        return cls.query.filter(cls.cvss_score >= threshold).all()

    def __repr__(self):
        return f'<Vulnerability {self.cve_id or self.vuln_id}: {self.title} ({self.severity})>'